/**
 * Minified by jsDelivr using Terser v5.3.5.
 * Original file: /npm/kalman-filter@1.9.2/test/unit/core/constant-speed-pendulum.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
const test=require("ava"),CoreKalmanFilter=require("../../../lib/core-kalman-filter.js"),State=require("../../../lib/state.js"),distanceMat=require("../../../lib/linalgebra/distance-mat.js"),getCorrelation=require("../../helpers/get-correlation.js"),huge=1e3,defaultOptions={observation:{dimension:1,stateProjection:()=>[[1,0]],covariance:()=>[[1]]},dynamic:{init:{mean:[[0],[0]],covariance:[[1e3,0],[0,1e3]]},dimension:2,transition:()=>[[1,timeStep],[0,1]],covariance:()=>[[.5,25e-5],[25e-5,.05]]}},timeStep=.1,observations=[[[0]],[[.2]],[[.3]]];test("Fitted observation",(e=>{const a=new CoreKalmanFilter(defaultOptions),t=new State({mean:[[0],[1]],covariance:[[1,0],[0,1]]}),n=a.predict({previousCorrected:t}),i=a.correct({predicted:n,observation:observations[1]}),r=a.correct({predicted:n,observation:[[.5]]});e.true(i instanceof State),e.true(r instanceof State);const o=distanceMat(t.mean,i.mean),c=distanceMat(t.mean,r.mean);e.true(o<c)})),test("Covariance between position and speed",(e=>{const a=new CoreKalmanFilter(defaultOptions),{covariance:t}=a.predict();e.not(t[0][1],0),e.not(t[1][0],0)})),test("Predicted variance",(e=>{const a=new State({mean:[[.1],[.5]],covariance:[[.1,1e-4],[1e-4,.001]]}),t=Object.assign({},defaultOptions,{observation:Object.assign({},defaultOptions.observation,{covariance:()=>[[10]]})}),n=new CoreKalmanFilter(t),i=n.correct({predicted:a,observation:[[.09]]}),r=n.correct({predicted:a,observation:[[.17]]}),o=[Math.abs(i.covariance[0][0]-a.covariance[0][0]),Math.abs(i.covariance[1][1]-a.covariance[1][1])],c=[Math.abs(r.covariance[0][0]-a.covariance[0][0]),Math.abs(r.covariance[1][1]-a.covariance[1][1])];e.is(o[0],c[0]),e.is(o[1],c[1]),e.is(i.covariance[1][0],r.covariance[1][0])})),test("Bad fit observation and correlation",(e=>{const a=new State({mean:[[.1],[.5]],covariance:[[.1,1e-4],[1e-4,.001]]}),t=Object.assign({},defaultOptions,{observation:Object.assign({},defaultOptions.observation,{covariance:()=>[[10]]})}),n=new CoreKalmanFilter(t).correct({predicted:a,observation:[[.17]]}),i=Math.abs(getCorrelation(a.covariance,0,1)-getCorrelation(n.covariance,0,1));e.true(i<.1)})),test("Non null covariance",(e=>{const a=new State({mean:[[.1],[.5]],covariance:[[1,.005],[.005,.01]]}),t=new State({mean:[[.1],[.5]],covariance:[[1,0],[0,.01]]}),n=Object.assign({},defaultOptions,{dynamic:Object.assign({},defaultOptions.dynamic,{transition:()=>[[.5,0],[0,.005]]})}),i=new CoreKalmanFilter(defaultOptions),r=new CoreKalmanFilter(n),o=i.predict({previousCorrected:a}),c=i.predict({previousCorrected:t}),s=r.predict({previousCorrected:a});e.true(Math.abs(o.covariance[0][1])>Math.abs(c.covariance[0][1])),e.true(Math.abs(o.covariance[0][1])>Math.abs(s.covariance[0][1])),e.true(Math.abs(o.covariance[0][0])>Math.abs(c.covariance[0][0])),e.true(Math.abs(o.covariance[0][0])>Math.abs(s.covariance[0][0]))})),test("getValue function",(e=>{const a=new State({mean:[[.1],[.5]],covariance:[[1,.005],[.005,.01]],index:1}),t=Object.assign({},defaultOptions,{dynamic:Object.assign({},defaultOptions.dynamic,{transition:function({previousCorrected:e,index:a}){return[[1,a%2?1:.5],[0,1-Math.min(.02^e.mean[1][0],1)]]}})}),n=new CoreKalmanFilter(t),i=n.predict({previousCorrected:a});e.true(i instanceof State);const r=new State({mean:[[.1],[3]],covariance:[[1,.005],[.005,.01]],index:1}),o=n.predict({previousCorrected:r});e.is(o.mean[1][0],0)}));
//# sourceMappingURL=/sm/38437435891f7859af30568f9b37487b043ec36f59f99288f09ec04f858cd13e.map