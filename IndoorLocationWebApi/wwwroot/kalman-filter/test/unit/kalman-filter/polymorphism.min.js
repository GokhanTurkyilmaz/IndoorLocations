/**
 * Minified by jsDelivr using Terser v5.3.5.
 * Original file: /npm/kalman-filter@1.9.2/test/unit/kalman-filter/polymorphism.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
const test=require("ava"),equalState=require("../../../test/helpers/equal-state.js"),KalmanFilter=require("../../../lib/kalman-filter.js"),State=require("../../../lib/state.js"),huge=1e6,timeStep=.1,defaultOptions={observation:{dimension:2,stateProjection:()=>[[1,0,0,0],[0,1,0,0]],covariance:()=>[[1,0],[0,1]]},dynamic:{init:{mean:[[0],[0],[0],[0]],covariance:[[huge,0,0,0],[0,huge,0,0],[0,0,huge,0],[0,0,0,huge]]},dimension:4,transition:()=>[[1,0,.1,0],[0,1,0,.1],[0,0,1,0],[0,0,0,1]],covariance:()=>[[1,0,0,0],[0,1,0,0],[0,0,.01,0],[0,0,0,.01]]}},observations=[[[1],[2]],[[2.1],[3.9]],[[3],[6]]];test("Polymorphism",(t=>{const e=new KalmanFilter(defaultOptions),i=Object.assign({},defaultOptions,{dynamic:Object.assign({},defaultOptions.dynamic,{transition:[[1,0,.1,0],[0,1,0,.1],[0,0,1,0],[0,0,0,1]]})}),n=Object.assign({},defaultOptions,{dynamic:Object.assign({},defaultOptions.dynamic,{covariance:[1,1,.01,.01]})}),a=new KalmanFilter(i),s=new KalmanFilter(n);t.is(typeof a.dynamic.transition,"object"),t.is(typeof s.dynamic.covariance,"object");const o=e.predict(),r=a.predict(),c=s.predict(),d=e.correct({predicted:o,observation:observations[0]}),l=a.correct({predicted:r,observation:observations[0]}),m=a.correct({predicted:c,observation:observations[0]});t.true(o instanceof State),t.true(r instanceof State),t.true(c instanceof State),t.true(d instanceof State),t.true(l instanceof State),t.true(m instanceof State),t.true(equalState(o,r)),t.true(equalState(o,c)),t.true(equalState(c,r)),t.true(equalState(d,l)),t.true(equalState(d,m)),t.true(equalState(m,l))})),test("Polymorphism on observation",(t=>{const e=new KalmanFilter(defaultOptions),i=e.predict(),n=e.correct({predicted:i,observation:observations[0]}),a=e.correct({predicted:i,observation:[1,2]});t.true(n instanceof State),t.true(a instanceof State),t.true(equalState(n,a))})),test("Dynamic init",(t=>{const e=Object.assign({},defaultOptions,{dynamic:Object.assign({},defaultOptions.dynamic,{init:void 0})}),i=new KalmanFilter(e),n=i.predict(),a=i.correct({predicted:n,observation:observations[0]});t.true(n instanceof State),t.true(a instanceof State),t.not(i.dynamic.init,void 0);const s=1e6,o={mean:[[0],[0],[0],[0]],index:-1,covariance:[[s,0,0,0],[0,s,0,0],[0,0,s,0],[0,0,0,s]]};t.deepEqual(i.dynamic.init,o);const r=new KalmanFilter(defaultOptions),c=r.predict(),d=r.correct({predicted:c,observation:observations[0]});t.true(equalState(n,c)),t.true(equalState(a,d))})),test("stateProjection dimensions",(t=>{const e=Object.assign({},defaultOptions,{dynamic:Object.assign({},defaultOptions.dynamic,{dimension:void 0}),observation:Object.assign({},defaultOptions.observation,{dimension:void 0,stateProjection:[[1,0,0,0],[0,1,0,0]]})}),i=new KalmanFilter(e);t.is(i.dynamic.dimension,4),t.is(i.observation.dimension,2)})),test("Transition dimension",(t=>{const e=Object.assign({},defaultOptions,{dynamic:Object.assign({},defaultOptions.dynamic,{dimension:void 0,transition:[[1,0,.1,0],[0,1,0,.1],[0,0,1,0],[0,0,0,1]]})}),i=new KalmanFilter(e);t.is(i.dynamic.dimension,4)})),test("Building stateProjection",(t=>{const e=Object.assign({},defaultOptions,{observation:Object.assign({},defaultOptions.observation,{stateProjection:void 0,observedProjection:[[1,0],[0,1]]})}),i=new KalmanFilter(e);t.deepEqual(i.observation.stateProjection,[[1,0,0,0],[0,1,0,0]])})),test("Dimension Error with stateProjection",(t=>{const e=Object.assign({},defaultOptions,{dynamic:Object.assign({},defaultOptions.dynamic,{dimension:4}),observation:Object.assign({},defaultOptions.observation,{dimension:2,stateProjection:[[1,0],[0,1]]})}),i=t.throws((()=>{new KalmanFilter(e).predict()}));t.is(i.message,"stateProjection dimensions not matching with observation and dynamic dimensions")})),test("Dimension Error with Transition",(t=>{const e=Object.assign({},defaultOptions,{dynamic:Object.assign({},defaultOptions.dynamic,{dimension:2,transition:[[1,0,.1,0],[0,1,0,.1],[0,0,1,0],[0,0,0,1]]})}),i=t.throws((()=>{new KalmanFilter(e).predict()}));t.is(i.message,"transition dimension not matching with dynamic dimension")})),test("Observed and State Projections",(t=>{const e=Object.assign({},defaultOptions,{observation:Object.assign({},defaultOptions.observation,{observedProjection:[[1,0],[0,1]],stateProjection:[[1,0,0,0],[0,1,0,0]]})}),i=t.throws((()=>{new KalmanFilter(e).predict()}));t.is(i.message,"You cannot use both observedProjection and stateProjection")})),test("Index initialization",(t=>{const e=new KalmanFilter(defaultOptions),i=new State({mean:[[0],[0],[0],[0]],covariance:[[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]]}),n=e.predict(),a=e.predict({previousCorrected:i});t.false(Number.isNaN(n.index)),t.false(Number.isNaN(a.index)),t.is(n.index,void 0),t.is(a.index,void 0)}));
//# sourceMappingURL=/sm/bc3703be94bec130297c9b67797b5580cba687a0f776b324392244f3fe8f61ea.map