/**
 * Minified by jsDelivr using Terser v5.3.5.
 * Original file: /npm/kalman-filter@1.9.2/test/unit/kalman-filter/register.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
const test=require("ava"),KalmanFilter=require("../../../lib/kalman-filter.js"),State=require("../../../lib/state.js"),equalState=require("../../helpers/equal-state.js"),modelCollection=require("../../../lib/model-collection.js"),identity=require("../../../lib/linalgebra/identity.js");test("Check constant position",(e=>{const t=new State({mean:[[0]],covariance:[[1]]}),n=new KalmanFilter({observation:{dimension:1,covariance:[[1]],stateProjection:[[1]]},dynamic:{dimension:1,name:"constant-position"}}).predict({previousCorrected:t}),a=new State({mean:[[0]],covariance:[[2]]});e.true(n instanceof State),e.true(equalState(n,a))})),test("Check constant speed",(e=>{const t=new State({mean:[[0],[1]],covariance:[[1,0],[0,1]]}),n=new KalmanFilter({observation:{dimension:1,covariance:[[1]],stateProjection:[[1,0]]},dynamic:{name:"constant-speed",covariance:[[1,0],[0,.01]],timeStep:.1}}),a=n.predict({previousCorrected:t}),i=n.correct({predicted:a,observation:[.11]}),o=new State({mean:[[.1+.006],[1]],covariance:[[.66,.033],[0,1.01]]});e.true(a instanceof State),e.true(i instanceof State),e.true(equalState(i,o,.1))})),test("Check constant acceleration",(e=>{const t=new State({mean:[[0],[1],[1]],covariance:[[1,0,0],[0,1,0],[0,0,1]]}),n=new KalmanFilter({observation:{dimension:1,covariance:[[1]],stateProjection:[[1,0,0]]},dynamic:{name:"constant-acceleration",covariance:[[1,0,0],[0,.01,0],[0,0,1e-4]],timeStep:.1}}),a=n.predict({previousCorrected:t}),i=n.correct({predicted:a,observation:[.11]});e.true(a instanceof State),e.true(i instanceof State)})),test("Check sensor",(e=>{const t=new State({mean:[[0],[1]],covariance:[[1,0],[0,1]]}),n=new KalmanFilter({dynamic:{name:"constant-speed",timeStep:.1,covariance:[1,.01]},observation:{name:"sensor",nSensors:2,sensorDimension:1,covariance:[1]}}),a=new KalmanFilter({dynamic:{name:"constant-speed",timeStep:.1,covariance:[1,.01]},observation:{dimension:2,stateProjection:[[1,0],[1,0]],covariance:[[1,0],[0,1]]}}),i=[[[.11],[.1]],[[.21],[.19]],[[.3],[.3]]],o=n.predict({previousCorrected:t,observation:i[0]});e.true(o instanceof State);const r=a.predict({previousCorrected:t,observation:i[0]});e.true(equalState(o,r))})),test("Registering custom speed",(e=>{const t=new KalmanFilter({dynamic:{name:"constant-speed",timeStep:.1,covariance:[1,.01]},observation:{name:"sensor"}});modelCollection.registerDynamic("custom-speed",((e,t)=>{const n=e.timeStep||1,{observedProjection:a}=t,{stateProjection:i}=t,o=t.dimension;let r;if(i&&Number.isInteger(i[0].length/2))r=t.stateProjection[0].length;else if(a)r=2*a[0].length;else{if(!o)throw new Error("observedProjection or stateProjection should be defined in observation in order to use constant-speed filter");r=2*o}const c=r/2,s=identity(r);for(let e=0;e<c;e++)s[e][e+c]=n;const m=new Array(c).fill(1).concat(new Array(c).fill(n*n));return{dimension:r,transition:s,covariance:e.covariance||m}}));const n=new KalmanFilter({dynamic:{name:"custom-speed",timeStep:.1,covariance:[1,.01]},observation:{name:"sensor"}}),a=t.predict(),i=n.predict();e.true(a instanceof State),e.true(i instanceof State),e.true(equalState(a,i))})),test("Init and registered model",(e=>{const t=new KalmanFilter({observation:{dimension:1,covariance:[[1]],stateProjection:[[1,0]]},dynamic:{name:"constant-speed",covariance:[[1,0],[0,.01]],timeStep:.1,init:{mean:[[0],[1]],covariance:[[1,0],[0,1]]}}});console.log(t.dynamic.init.covariance),e.deepEqual(t.dynamic.init.covariance,[[1,0],[0,1]])}));
//# sourceMappingURL=/sm/4aaf71132f03fde4b245409e2e7744b0c070f1b86f9dbbd76036d18d759076e4.map