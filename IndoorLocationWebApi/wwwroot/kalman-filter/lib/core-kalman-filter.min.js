/**
 * Minified by jsDelivr using Terser v5.3.5.
 * Original file: /npm/kalman-filter@1.9.2/lib/core-kalman-filter.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
const matMul=require("../lib/linalgebra/mat-mul.js"),transpose=require("../lib/linalgebra/transpose.js"),add=require("../lib/linalgebra/add.js"),invert=require("../lib/linalgebra/invert.js"),sub=require("../lib/linalgebra/sub.js"),getIdentity=require("../lib/linalgebra/identity.js"),State=require("./state.js"),checkMatrix=require("./utils/check-matrix.js"),defaultLogger={info:(...e)=>console.log(...e),debug:()=>{},warn:(...e)=>console.log(...e),error:(...e)=>console.log(...e)};class CoreKalmanFilter{constructor({dynamic:e,observation:t,logger:i=defaultLogger}){this.dynamic=e,this.observation=t,this.logger=i}getValue(e,t){return"function"==typeof e?e(t):e}getInitState(){const{mean:e,covariance:t,index:i}=this.dynamic.init;return new State({mean:e,covariance:t,index:i})}getPredictedCovariance(e={}){let{previousCorrected:t,index:i}=e;t=t||this.getInitState();const n=Object.assign({},{previousCorrected:t,index:i},e),a=this.getValue(this.dynamic.transition,n),r=transpose(a),o=matMul(a,t.covariance),s=matMul(o,r),c=this.getValue(this.dynamic.covariance,n),d=add(c,s);return checkMatrix(d,[this.dynamic.dimension,this.dynamic.dimension],"predicted.covariance"),d}predict(e={}){let{previousCorrected:t,index:i}=e;t=t||this.getInitState(),"number"!=typeof i&&"number"==typeof t.index&&(i=t.index+1),State.check(t,{dimension:this.dynamic.dimension});const n=Object.assign({},{previousCorrected:t,index:i},e),a=this.getValue(this.dynamic.transition,n);checkMatrix(a,[this.dynamic.dimension,this.dynamic.dimension],"dynamic.transition");const r=matMul(a,t.mean),o=this.getPredictedCovariance(n),s=new State({mean:r,covariance:o,index:i});return this.logger.debug("Prediction done",s),s}getGain(e){let{predicted:t,stateProjection:i}=e;const n=Object.assign({},{index:t.index},e);i=i||this.getValue(this.observation.stateProjection,n);const a=this.getValue(this.observation.covariance,n);checkMatrix(a,[this.observation.dimension,this.observation.dimension],"observation.covariance");const r=transpose(i),o=matMul(matMul(i,t.covariance),r),s=add(o,a);return matMul(matMul(t.covariance,r),invert(s))}getCorrectedCovariance(e){let{predicted:t,optimalKalmanGain:i,stateProjection:n}=e;const a=getIdentity(t.covariance.length);if(!n){const i=Object.assign({},{index:t.index},e);n=this.getValue(this.observation.stateProjection,i)}return i||(i=this.getGain(Object.assign({stateProjection:n},e))),matMul(sub(a,matMul(i,n)),t.covariance)}correct(e){const{predicted:t,observation:i}=e;if(State.check(t,{dimension:this.dynamic.dimension}),!i)throw new Error("no measure available");const n=Object.assign({},{observation:i,predicted:t,index:t.index},e),a=this.getValue(this.observation.stateProjection,n),r=this.getGain(Object.assign({predicted:t,stateProjection:a},e)),o=sub(i,matMul(a,t.mean)),s=add(t.mean,matMul(r,o));if(Number.isNaN(s[0][0]))throw console.log({optimalKalmanGain:r,innovation:o,predicted:t}),new TypeError("Mean is NaN after correction");const c=this.getCorrectedCovariance(Object.assign({predicted:t,optimalKalmanGain:r,stateProjection:a},e)),d=new State({mean:s,covariance:c,index:t.index});return this.logger.debug("Correction done",d),d}}module.exports=CoreKalmanFilter;
//# sourceMappingURL=/sm/f94f960f0ec74d03a8dd8df579f0c743e3060c91b359beb24bb9393c1bbf1c79.map