/**
 * Minified by jsDelivr using Terser v5.3.5.
 * Original file: /npm/kalman-filter@1.9.2/lib/kalman-filter.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
const arrayToMatrix=require("../lib/utils/array-to-matrix.js"),setDimensions=require("../lib/setup/set-dimensions.js"),checkDimensions=require("../lib/setup/check-dimensions.js"),buildStateProjection=require("../lib/setup/build-state-projection.js"),extendDynamicInit=require("../lib/setup/extend-dynamic-init.js"),toFunction=require("../lib/utils/to-function.js"),deepAssign=require("../lib/utils/deep-assign.js"),polymorphMatrix=require("../lib/utils/polymorph-matrix.js"),distanceMat=require("../lib/linalgebra/distance-mat.js"),State=require("./state.js"),modelCollection=require("./model-collection.js"),CoreKalmanFilter=require("./core-kalman-filter.js"),buildDefaultDynamic=function(e){return"string"==typeof e?{name:e}:{name:"constant-position"}},buildDefaultObservation=function(e){return"number"==typeof e?{name:"sensor",sensorDimension:e}:"string"==typeof e?{name:e}:{name:"sensor"}},setupModelsParameters=function({observation:e,dynamic:t}){"object"==typeof e&&null!==e||(e=buildDefaultObservation(e)),"object"==typeof t&&null!==t||(t=buildDefaultDynamic(t)),"string"==typeof e.name&&(e=modelCollection.buildObservation(e)),"string"==typeof t.name&&(t=modelCollection.buildDynamic(t,e));const i=setDimensions({observation:e,dynamic:t}),n=checkDimensions(i),o=buildStateProjection(n);return extendDynamicInit(o)},modelsParametersToCoreOptions=function(e){const{observation:t,dynamic:i}=e;return deepAssign(e,{observation:{stateProjection:toFunction(polymorphMatrix(t.stateProjection)),covariance:toFunction(polymorphMatrix(t.covariance,{dimension:t.dimension}))},dynamic:{transition:toFunction(polymorphMatrix(i.transition)),covariance:toFunction(polymorphMatrix(i.covariance,{dimension:i.dimension}))}})};class KalmanFilter extends CoreKalmanFilter{constructor(e={}){const t=setupModelsParameters(e),i=modelsParametersToCoreOptions(t);super(Object.assign({},e,i))}correct(e){const t=arrayToMatrix({observation:e.observation,dimension:this.observation.dimension});return super.correct(Object.assign({},e,{observation:t}))}filter(e){const t=super.predict(e);return this.correct(Object.assign({},e,{predicted:t}))}filterAll(e){const{mean:t,covariance:i,index:n}=this.dynamic.init;let o=new State({mean:t,covariance:i,index:n});const r=[];for(const t of e){const e=this.predict({previousCorrected:o});o=this.correct({predicted:e,observation:t}),r.push(o.mean.map((e=>e[0])))}return r}asymptoticStateCovariance(e=100,t=1e-6){let i,n=super.getInitState();const o=[];for(let r=0;r<e;r++)if(i=new State({mean:null,covariance:super.getPredictedCovariance({previousCorrected:n})}),n=new State({mean:null,covariance:super.getCorrectedCovariance({predicted:i})}),o.push(n.covariance),distanceMat(n.covariance,o[r-1])<t)return o[r];throw new Error("The state covariance does not converge asymptotically")}asymptoticGain(e=1e-6){const t=this.asymptoticStateCovariance(e),i=new State({mean:new Array(t.length).fill(0).map((()=>[0])),covariance:t});return super.getGain({previousCorrected:i})}}module.exports=KalmanFilter;
//# sourceMappingURL=/sm/4f525ee92f4e81dd28ff0046c99e1b8d73747b84c447cf4365f8ee3ab19afc30.map