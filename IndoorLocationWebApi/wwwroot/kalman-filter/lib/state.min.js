/**
 * Minified by jsDelivr using Terser v5.3.5.
 * Original file: /npm/kalman-filter@1.9.2/lib/state.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
const sub=require("./linalgebra/sub.js"),transpose=require("./linalgebra/transpose.js"),matMul=require("./linalgebra/mat-mul.js"),invert=require("./linalgebra/invert.js"),elemWise=require("./linalgebra/elem-wise.js"),subSquareMatrix=require("./linalgebra/sub-square-matrix"),arrayToMatrix=require("./utils/array-to-matrix.js"),checkMatrix=require("./utils/check-matrix.js"),checkCovariance=require("./utils/check-covariance");class State{constructor({mean:e,covariance:a,index:t}){this.mean=e,this.covariance=a,this.index=t}check(e){this.constructor.check(this,e)}static check(e,{dimension:a=null,title:t=null,eigen:r}={}){if(!(e instanceof State))throw new TypeError("The argument is not a state \nTips: maybe you are using 2 different version of kalman-filter in your npm deps tree");const{mean:i,covariance:n}=e,s=i.length;if("number"==typeof a&&s!==a)throw new Error(`[${t}] State.mean ${i} with dimension ${s} does not match expected dimension (${a})`);checkMatrix(i,[s,1],t?t+"-mean":"mean"),checkMatrix(n,[s,s],t?t+"-covariance":"covariance"),checkCovariance({covariance:n,eigen:r},t?t+"-covariance":"covariance")}static matMul({state:e,matrix:a}){const t=matMul(matMul(a,e.covariance),transpose(a)),r=matMul(a,e.mean);return new State({mean:r,covariance:t,index:e.index})}subState(e){return new State({mean:e.map((e=>this.mean[e])),covariance:subSquareMatrix(this.covariance,e),index:this.index})}rawDetailedMahalanobis(e){const a=sub(this.mean,e);this.check();const t=invert(this.covariance);if(null===t)throw this.check({eigen:!0}),new Error("Cannot invert covariance "+JSON.stringify(this.covariance));const r=transpose(a),i=Math.sqrt(matMul(matMul(r,t),a));if(Number.isNaN(i))throw console.log({diff:a,covarianceInvert:t,this:this,point:e},matMul(matMul(r,t),a)),new Error("mahalanobis is NaN");return{diff:a,covarianceInvert:t,value:i}}detailedMahalanobis({kf:e,observation:a,obsIndexes:t}){if(a.length!==e.observation.dimension)throw new Error(`Mahalanobis observation ${a} (dimension: ${a.length}) does not match with kf observation dimension (${e.observation.dimension})`);let r=arrayToMatrix({observation:a,dimension:a.length});const i=e.getValue(e.observation.stateProjection,{});let n=this.constructor.matMul({state:this,matrix:i});return Array.isArray(t)&&(n=n.subState(t),r=t.map((e=>r[e]))),n.rawDetailedMahalanobis(r)}mahalanobis(e){const a=this.detailedMahalanobis(e).value;if(Number.isNaN(a))throw new TypeError("mahalanobis is NaN");return a}obsBhattacharyya({kf:e,state:a,obsIndexes:t}){const r=e.getValue(e.observation.stateProjection,{});let i=this.constructor.matMul({state:this,matrix:r}),n=this.constructor.matMul({state:a,matrix:r});return Array.isArray(t)&&(i=i.subState(t),n=n.subState(t)),i.bhattacharyya(n)}bhattacharyya(e){const a=elemWise([this.covariance,e.covariance],(([e,a])=>(e+a)/2));let t;try{t=invert(a)}catch(e){throw console.log("Cannot invert",a),e}const r=sub(this.mean,e.mean);return matMul(transpose(r),matMul(t,r))[0][0]}}module.exports=State;
//# sourceMappingURL=/sm/03d07d3799ea626b161a060ba0740d36342eb0c3f468656861e80c565655b522.map